\chapter{Podsumowanie}

Powstały w niniejszej pracy system weryfikacji mówcy osiągnął dobry wynik błędu ERR równy 6\% w teście zawierającym ograniczony materiał nagrań. Każde nagranie zostało zarejestrowane w podobnych warunkach z zakłóceniami tła oraz zawierało tę samą treść. Z tych powodów aby otrzymać bardziej wiarygodne wyniki efektywności otrzymanego systemu należy wykonać bardziej rozległe testy, najlepiej przy użyciu dużych baz wypowiedzi mówców powstałych w tym właśnie celu takie jak baza NIST (\textit{National Institute of Standards and Technology}) albo ELRA (European Language Resources Association). Implementacja otrzymanego przykładowego systemu składa się tylko z niezbędnych elementów potrzebnych do jego uruchomienia. Jednak przedstawiona w rozdziale 2 architektura systemu pozwala na szeroką ingerencję jeżeli chodzi o dodawanie do systemu nowych technik poprawiających efektywność systemu. W uruchomionym na potrzeby tej pracy systemie niezbędne było by wprowadzenie technik detekcji mówcy (VAD) tak aby puste ramki cech MFCC nie wpływały na efekt procesu tworzenia modelu mówcy (ze względu na modyfikację otrzymanych centroid modelu). Tak jak wspomniano na wstępie pracy, warto dostarczyć do systemu więcej materiału trenującego (np. parokrotne powtórzenia wszystkich cyfr dla każdego mówcy w przypadku systemu z wyświetlanym hasłem). W zastosowaniach z przetwarzaniem sygnału mowy w czasie rzeczywistym uwzględnienie podsystemu \textit{speaker pruning} (opisanego w sekcji \textbf{\ref{speakerprunning}}) może okazać się przydatne dla zwiększenia szybkości pracy systemu.

Autor uważa, że zaproponowana architektura i sposób implementacji w języku C++ może być bazą do stworzenia obszerniejszego 'frameworku' dla prac związanych z konstruowaniem systemów weryfikacji mówcy dla systemów wbudowanych. Wydaje się, że jest możliwa efektywna i jasna implementacja w proponowanym środowisku większości technik omawianych w części teoretycznej tej pracy.
